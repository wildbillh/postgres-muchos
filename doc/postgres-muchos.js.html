<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: postgres-muchos.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: postgres-muchos.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

let GenericPool = require('generic-pool');
let pg = require ('pg');
let EventEmitter = require('events').EventEmitter;

/**
 *
 */
class PostgresMuchos extends EventEmitter {
    /**
     * @constructor
     * @param {object} dbConfig - The Database connection properties
     * @param {string} dbConfig.host
     * @param {string} dbConfig.user
     * @param {string} dbConfig.password
     * @param {number} [dbConfig.port=5432]
     * @param {string} [dbConfig.database]
     * @param {object} poolConfig - The pool configuration. See the [generic-pool]{@link https://github.com/coopernurse/node-pool} documentation
     * for more information.
     * @param {number} [poolConfig.min=0] Number of clients to start with
     * @param {number} [poolConfig.max=10] Max number of clients in the pool
     * @param {number} [poolConfig.idleTimout=30000] Number of milliseconds of inactivity before closing
     * @param {number} [poolConfig.acquireTimeoutMillis=1000] How long to keep trying to connect before giving up.
     * Note this is different then the generic-pool default of 0.
     * @param {object} [emitControl] Used to control which events are emitted.
     * @param {boolean} [emitControl.connect=false] Emit a &lt;a href="#connect">connect&lt;/a> event with the process ID.
     * @param {boolean} [emitControl.disconnect=false] Emit a &lt;a href="#disconnect">disconnect&lt;/a> event with the process ID.
     * @param {boolean} [emitControl.query=false] Emit a &lt;a href="#query">query&lt;/a> event for all submitted sql.
     * @param {boolean} [emitControl.results=false] Emit a &lt;a href="#results">results&lt;/a> event when results are available.
     * Also includes processID, query and elapsedTime (ms).
     */
    constructor (dbConfig, poolConfig, emitControl = {}) {
        super();
        let factory = this.createFactory(dbConfig);
        // Initialize the member variable. We add this to the returned
        // error message if there is an issue with the connection.
        this._onErrorMessage = null;
        this._emitControl = emitControl;

        // Set the default value of acquireTimeoutMillis if not supplied.
        !poolConfig.acquireTimeoutMillis &amp;&amp; (poolConfig.acquireTimeoutMillis = 1000);

        // create the pool
        this._pool = GenericPool.createPool(factory, poolConfig);

        // Listen for the factory create error event and store the value in a member variable
        this._pool.on('factoryCreateError', (err) => {
            err &amp;&amp; (this._onErrorMessage = err);
        });
    }

    /**
     * Create the factory object needed by generic-pool
     * @private
     * @param config
     * @returns {{create: (function()), validate: (function(*)), destroy: (function(*=))}}
     */
    createFactory (config) {
        let that = this;
        return {
            create: () => {
                return new Promise(function (resolve, reject) {
                    // get a new pg client
                    let client = new pg.Client(config);
                    // pg complains if you don't listen to the error response
                    client.on('error', () => {});
                    // connect to the client
                    client.connect((err) => {
                        if (err) {
                            return reject(err.message);
                        }
                        else {
                            // Emit a connect event if configured.
                            that._emitControl.connect &amp;&amp; that.emit('connect', {event: 'connect', processID: client.processID});
                            return resolve(client);
                        }
                    })
                });
            },

            validate: (client) => {
                return new Promise( (resolve, reject) => {
                    client.query('select 1', [], function(err, results) {
                        if (err) {
                            return reject(false);
                        }
                        return resolve(true);
                    });
                })
            },
            destroy: (client) => {
                return new Promise(function(resolve, reject){
                    client.end( (err) => {
                        if (err) {
                            return reject(err);
                        }
                        // Emit an disconnect event if configured
                        that._emitControl.disconnect &amp;&amp; that.emit('disconnect', {event: 'disconnect', processID: client.processID});
                        return resolve();
                    })
                })
            }
        };
    }

    /**
     * Wraps the pg client.query in a promise. Also emits events as configured
     * @param client
     * @param sql
     * @param parms
     * @returns {Promise}
     * @private
     */
    _query  (client, sql, parms) {
        let that = this;
        let start = new Date().getTime();
        return new Promise((resolve, reject) => {
            client.query(sql, parms, function (err, results) {
                if (err) {
                    return reject(err);
                }
                that._onErrorMessage = null;
                // if the query event is configured, emit it.
                that._emitControl.query &amp;&amp; that.emit('query',
                    {event: 'query', sql: sql, parms: parms, processID: client.processID}
                );
                // if the results event is configured, emit it.
                if (that._emitControl.results) {
                    let elapsedTime = new Date().getTime() - start;
                    that.emit('results',
                        {event: 'results', elapsedTime: elapsedTime, sql: sql,
                        parms: parms, data: results.rows, processID: client.processID }
                    );

                }
                return resolve(results);
            });
        });
    }

    /**
     * Submit SQL or DDL to the database server. Returns a promise. The data structure of the
     * returned object is somewhat documented below.
     * @param sql {String} Valid SQL or DDL to apply to the DB
     * @param parms List of parameters to apply to the sql string
     * @fires PostgresMuchos#query
     * @fires PostgresMuchos#results
     * @returns {Promise} - On success, the promise will be resolved and a data object will be
     * returned. The promise will be rejected and an error message returned on error.
     * @returns {Object} results - The returned data object.
     * @returns {String} results.command - The type of query submitted: 'SELECT', 'UPDATE', etc.
     * @returns {Number} results.rowCount - The number of rows returned.
     * @returns {Array} results.fields - An Array of Objects describing the columns returned. Usefull
     * properties are name, columnID, format ... ect.
     * @returns {Array} results.rows - An Array of Objects equal to the size of rowCount above. Each
     * object contains properties matching the return column names.
     */
    query (sql, parms = []) {
        return new Promise((resolve, reject) => {
            let client = null;

            this._pool.acquire(0)
            .then ((clientParm) => {

                client = clientParm;
                return this._query(client, sql, parms);
            })
            .then( (results) => {
                this._pool.release(client).then();
                return resolve(results);
            })
            .catch( (err) => {
                this._pool &amp;&amp; this._pool.release(client)
                .then(() => {
                })
                .catch( () => {
                });

                reject(`${err.message}: ${this._onErrorMessage ? this._onErrorMessage : ""}`);
                //console.log(this._onErrorMessage);
            });
        });
    }

    /**
     * Close all of the pool connections. No new connections can be opened.
     * @fires PostgresMuchos#disconnect
     * @returns {Promise}
     */
    close () {
        return new Promise( (resolve, reject) => {
            this._pool &amp;&amp; this._pool.drain()
            .then ( () => {
                return this._pool.clear();
            })
            .then ( () => {
                return resolve();
            })
            .catch( (err) => {
                return reject (err);
            })
        });
    }

    /**
    * Exposes the underlying pool object. For advanced users only
    * @returns {Object} - The underlying pool object. See the documentation for any-db.
    */
    get pool () {
        return this._pool;
    }

    /**
     *  &lt;div id="connect"/>
     * The connect event is emitted when a client is acquired from the pool.
     * @event PostgresMuchos#connect
     * @type {string}
     * @property {string} event Always contains the string 'connect'
     * @property {number} processID Contains the process ID of the acquired client.
     */

    /**
     * &lt;div id="disconnect"/>
     * The disconnect event is emitted when a client is released from the pool.
     * @event PostgresMuchos#disconnect
     * @type {string}
     * @property {string} event Always contains the string 'disconnect'
     * @property {number} processID Contains the process ID to be closed.
     */

    /**
     * &lt;div id="query"/>
     * The query event is emitted when the query method is called, but before the
     * submission to the db. The object emitted has the process ID of the client and the sql. This is often
     * useful for debugging purposes.
     * @event PostgresMuchos#query
     * @type {object}
     * @property {string} event Always contains the string 'query'.
     * @property {number} processID The process ID of the DB connection.
     * @property {string} sql The sql that was invoked.
     * @property {array} parms The paramters passed with the sql command.
     *
     *
     */

    /**
     * &lt;div id="results"/>
     * The results event is emitted when the query method has resolved.
     * Configuring this event could slow processing slightly. For
     * performant applications, it should be turned off with emitControl.
     * @event PostgresMuchos#results
     * @type {object}
     * @property {string} event Always contains the string 'results'.
     * @property {number} elapsedTime The number of milliseconds between the invoke and results.
     * @property {string} sql The sql that was invoked.
     * @property {array} parms The parameters passed with the sql command.
     * @property {array} data The results.rows object returned.
     */

}

module.exports = PostgresMuchos;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="PostgresMuchos.html">PostgresMuchos</a></li></ul><h3>Events</h3><ul><li><a href="PostgresMuchos.html#event:connect">connect</a></li><li><a href="PostgresMuchos.html#event:disconnect">disconnect</a></li><li><a href="PostgresMuchos.html#event:query">query</a></li><li><a href="PostgresMuchos.html#event:results">results</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Fri Nov 04 2016 15:11:32 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
